<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2024-08-19T14:46:06.665567776"><title>Arreglos Din&aacute;micos vs Arreglos Est&aacute;ticos en C++ | Instance Name</title><script type="application/json" id="virtual-toc-data">[{"id":"1-introducci-n","level":0,"title":"1. Introducción","anchor":"#1-introducci-n"},{"id":"2-arreglos-est-ticos","level":0,"title":"2. Arreglos Estáticos","anchor":"#2-arreglos-est-ticos"},{"id":"3-arreglos-din-micos","level":0,"title":"3. Arreglos Dinámicos","anchor":"#3-arreglos-din-micos"},{"id":"4-contenedores-en-la-stl-std-vector-y-std-array","level":0,"title":"4. Contenedores en la STL: std::vector y std::array","anchor":"#4-contenedores-en-la-stl-std-vector-y-std-array"},{"id":"5-manejo-de-memoria-con-std-vector-y-std-array","level":0,"title":"5. Manejo de Memoria con std::vector y std::array","anchor":"#5-manejo-de-memoria-con-std-vector-y-std-array"},{"id":"6-buenas-pr-cticas","level":0,"title":"6. Buenas Prácticas","anchor":"#6-buenas-pr-cticas"},{"id":"7-conclusi-n","level":0,"title":"7. Conclusión","anchor":"#7-conclusi-n"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b408/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Arreglos Din&aacute;micos vs Arreglos Est&aacute;ticos en C++ | Instance Name"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Instance Name Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/arreglos-dinamicos.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Arreglos Din&aacute;micos vs Arreglos Est&aacute;ticos en C++ | Instance Name"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/arreglos-dinamicos.html#webpage",
    "url": "writerside-documentation/arreglos-dinamicos.html",
    "name": "Arreglos Din&aacute;micos vs Arreglos Est&aacute;ticos en C++ | Instance Name",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Instance Name Help"
}</script><!-- End Schema.org --></head><body data-id="Arreglos-Dinamicos" data-main-title="Arreglos Dinámicos vs Arreglos Estáticos en C++" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs=""><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Instance Name  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Arreglos-Dinamicos" id="Arreglos-Dinamicos.md">Arreglos Dinámicos vs Arreglos Estáticos en C++</h1><section class="chapter"><h2 id="1-introducci-n" data-toc="1-introducci-n">1. Introducci&oacute;n</h2><p id="-py2pby_10">En C++, los arreglos pueden ser gestionados de dos maneras principales: de forma est&aacute;tica y de forma din&aacute;mica. Cada enfoque tiene sus propias caracter&iacute;sticas, ventajas, y limitaciones, y el uso adecuado depende del contexto del problema que se est&eacute; resolviendo. Adem&aacute;s, C++ proporciona contenedores est&aacute;ndar como <code class="code" id="-py2pby_11">std::vector</code> y <code class="code" id="-py2pby_12">std::array</code>, que ofrecen funcionalidades adicionales para trabajar con arreglos.</p></section><section class="chapter"><h2 id="2-arreglos-est-ticos" data-toc="2-arreglos-est-ticos">2. Arreglos Est&aacute;ticos</h2><section class="chapter"><h3 id="2-1-definici-n-y-uso" data-toc="2-1-definici-n-y-uso">2.1 Definici&oacute;n y Uso</h3><p id="-py2pby_16">Un <span class="control" id="-py2pby_18">arreglo est&aacute;tico</span> en C++ es un arreglo cuyo tama&ntilde;o se determina en tiempo de compilaci&oacute;n. La memoria para este tipo de arreglo se asigna en el stack, y su tama&ntilde;o es fijo durante toda la ejecuci&oacute;n del programa.</p><div class="code-block" data-lang="none">
int arr[5] = {1, 2, 3, 4, 5}; // Arreglo estático de 5 enteros
</div></section><section class="chapter"><h3 id="2-2-ventajas" data-toc="2-2-ventajas">2.2 Ventajas</h3><ul class="list _bullet" id="-py2pby_19"><li class="list__item" id="-py2pby_20"><p><span class="control" id="-py2pby_23">Simplicidad</span>: Son f&aacute;ciles de declarar y usar.</p></li><li class="list__item" id="-py2pby_21"><p><span class="control" id="-py2pby_24">Eficiencia</span>: Debido a que la memoria se asigna en el stack, el acceso y la manipulaci&oacute;n de datos son r&aacute;pidos.</p></li><li class="list__item" id="-py2pby_22"><p><span class="control" id="-py2pby_25">Menor Sobrecarga</span>: No requieren la gesti&oacute;n expl&iacute;cita de la memoria.</p></li></ul></section><section class="chapter"><h3 id="2-3-limitaciones" data-toc="2-3-limitaciones">2.3 Limitaciones</h3><ul class="list _bullet" id="-py2pby_26"><li class="list__item" id="-py2pby_27"><p><span class="control" id="-py2pby_29">Tama&ntilde;o Fijo</span>: No se puede cambiar el tama&ntilde;o del arreglo una vez declarado.</p></li><li class="list__item" id="-py2pby_28"><p><span class="control" id="-py2pby_30">Peligro de Desbordamiento</span>: Si intentas acceder a una posici&oacute;n fuera de los l&iacute;mites del arreglo, se puede causar un comportamiento indefinido.</p></li></ul></section></section><section class="chapter"><h2 id="3-arreglos-din-micos" data-toc="3-arreglos-din-micos">3. Arreglos Din&aacute;micos</h2><section class="chapter"><h3 id="3-1-definici-n-y-uso" data-toc="3-1-definici-n-y-uso">3.1 Definici&oacute;n y Uso</h3><p id="-py2pby_34">Un <span class="control" id="-py2pby_36">arreglo din&aacute;mico</span> en C++ es un arreglo cuyo tama&ntilde;o se puede definir en tiempo de ejecuci&oacute;n. La memoria para este tipo de arreglo se asigna en el heap, y su tama&ntilde;o puede ser gestionado din&aacute;micamente.</p><div class="code-block" data-lang="none">
int* arr = new int[5]; // Arreglo dinámico de 5 enteros
</div></section><section class="chapter"><h3 id="3-2-ventajas" data-toc="3-2-ventajas">3.2 Ventajas</h3><ul class="list _bullet" id="-py2pby_37"><li class="list__item" id="-py2pby_38"><p><span class="control" id="-py2pby_40">Flexibilidad</span>: El tama&ntilde;o del arreglo puede ser determinado en tiempo de ejecuci&oacute;n.</p></li><li class="list__item" id="-py2pby_39"><p><span class="control" id="-py2pby_41">Gesti&oacute;n Din&aacute;mica de Memoria</span>: Puedes reasignar o liberar memoria seg&uacute;n las necesidades del programa.</p></li></ul></section><section class="chapter"><h3 id="3-3-limitaciones" data-toc="3-3-limitaciones">3.3 Limitaciones</h3><ul class="list _bullet" id="-py2pby_42"><li class="list__item" id="-py2pby_43"><p><span class="control" id="-py2pby_45">Complejidad</span>: Requieren gesti&oacute;n expl&iacute;cita de la memoria (uso de <code class="code" id="-py2pby_46">new</code> y <code class="code" id="-py2pby_47">delete</code>).</p></li><li class="list__item" id="-py2pby_44"><p><span class="control" id="-py2pby_48">Sobrecarga de Memoria</span>: La gesti&oacute;n de memoria en el heap puede ser m&aacute;s lenta y propensa a errores como fugas de memoria.</p></li></ul></section></section><section class="chapter"><h2 id="4-contenedores-en-la-stl-std-vector-y-std-array" data-toc="4-contenedores-en-la-stl-std-vector-y-std-array">4. Contenedores en la STL: <code class="code" id="-py2pby_53">std::vector</code> y <code class="code" id="-py2pby_54">std::array</code></h2><section class="chapter"><h3 id="4-1-std-array" data-toc="4-1-std-array">4.1 <code class="code" id="-py2pby_59">std::array</code></h3><section class="chapter"><h4 id="4-1-1-definici-n-y-uso" data-toc="4-1-1-definici-n-y-uso">4.1.1 Definici&oacute;n y Uso</h4><p id="-py2pby_60"><code class="code" id="-py2pby_62">std::array</code> es un contenedor de tama&ntilde;o fijo que es parte de la librer&iacute;a est&aacute;ndar de C++ (STL). Combina la eficiencia de los arreglos est&aacute;ticos con la funcionalidad de los contenedores de la STL.</p><div class="code-block" data-lang="none">
#include &lt;array&gt;

std::array&lt;int, 5&gt; arr = {1, 2, 3, 4, 5}; // Arreglo estático con la STL
</div></section><section class="chapter"><h4 id="4-1-2-ventajas" data-toc="4-1-2-ventajas">4.1.2 Ventajas</h4><ul class="list _bullet" id="-py2pby_63"><li class="list__item" id="-py2pby_64"><p><span class="control" id="-py2pby_66">Tama&ntilde;o Fijo en Tiempo de Compilaci&oacute;n</span>: Como los arreglos est&aacute;ticos, pero con las ventajas de la STL.</p></li><li class="list__item" id="-py2pby_65"><p><span class="control" id="-py2pby_67">M&eacute;todos de la STL</span>: Proporciona m&eacute;todos como <code class="code" id="-py2pby_68">.size()</code>, <code class="code" id="-py2pby_69">.at()</code>, y soporte para iteradores.</p></li></ul></section><section class="chapter"><h4 id="4-1-3-funciones-principales" data-toc="4-1-3-funciones-principales">4.1.3 Funciones Principales</h4><ul class="list _bullet" id="-py2pby_70"><li class="list__item" id="-py2pby_71"><p><code class="code" id="-py2pby_74">.size()</code>: Retorna el tama&ntilde;o del arreglo.</p></li><li class="list__item" id="-py2pby_72"><p><code class="code" id="-py2pby_75">.at(index)</code>: Accede a un elemento en la posici&oacute;n <code class="code" id="-py2pby_76">index</code> con verificaci&oacute;n de l&iacute;mites.</p></li><li class="list__item" id="-py2pby_73"><p><code class="code" id="-py2pby_77">.begin()</code>, <code class="code" id="-py2pby_78">.end()</code>: Retorna iteradores al inicio y final del arreglo.</p></li></ul></section></section><section class="chapter"><h3 id="4-2-std-vector" data-toc="4-2-std-vector">4.2 <code class="code" id="-py2pby_83">std::vector</code></h3><section class="chapter"><h4 id="4-2-1-definici-n-y-uso" data-toc="4-2-1-definici-n-y-uso">4.2.1 Definici&oacute;n y Uso</h4><p id="-py2pby_84"><code class="code" id="-py2pby_86">std::vector</code> es un contenedor din&aacute;mico que se encuentra en la STL. Permite crear arreglos que pueden cambiar de tama&ntilde;o durante la ejecuci&oacute;n del programa.</p><div class="code-block" data-lang="none">
#include &lt;vector&gt;

std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5}; // Vector dinámico
vec.push_back(6); // Agregar un nuevo elemento al final
</div></section><section class="chapter"><h4 id="4-2-2-ventajas" data-toc="4-2-2-ventajas">4.2.2 Ventajas</h4><ul class="list _bullet" id="-py2pby_87"><li class="list__item" id="-py2pby_88"><p><span class="control" id="-py2pby_91">Redimensionamiento Din&aacute;mico</span>: Los <code class="code" id="-py2pby_92">std::vector</code> pueden crecer o reducirse seg&uacute;n sea necesario.</p></li><li class="list__item" id="-py2pby_89"><p><span class="control" id="-py2pby_93">Gesti&oacute;n Autom&aacute;tica de Memoria</span>: No es necesario gestionar manualmente la asignaci&oacute;n y liberaci&oacute;n de memoria.</p></li><li class="list__item" id="-py2pby_90"><p><span class="control" id="-py2pby_94">Funciones de la STL</span>: Proporciona m&eacute;todos como <code class="code" id="-py2pby_95">.push_back()</code>, <code class="code" id="-py2pby_96">.pop_back()</code>, <code class="code" id="-py2pby_97">.resize()</code>, y soporte completo para iteradores.</p></li></ul></section><section class="chapter"><h4 id="4-2-3-funciones-principales" data-toc="4-2-3-funciones-principales">4.2.3 Funciones Principales</h4><ul class="list _bullet" id="-py2pby_98"><li class="list__item" id="-py2pby_99"><p><code class="code" id="-py2pby_104">.size()</code>: Retorna el n&uacute;mero de elementos en el vector.</p></li><li class="list__item" id="-py2pby_100"><p><code class="code" id="-py2pby_105">.push_back(value)</code>: Agrega un elemento al final del vector.</p></li><li class="list__item" id="-py2pby_101"><p><code class="code" id="-py2pby_106">.pop_back()</code>: Elimina el &uacute;ltimo elemento del vector.</p></li><li class="list__item" id="-py2pby_102"><p><code class="code" id="-py2pby_107">.resize(new_size)</code>: Cambia el tama&ntilde;o del vector.</p></li><li class="list__item" id="-py2pby_103"><p><code class="code" id="-py2pby_108">.at(index)</code>: Accede al elemento en la posici&oacute;n <code class="code" id="-py2pby_109">index</code> con verificaci&oacute;n de l&iacute;mites.</p></li></ul></section></section><section class="chapter"><h3 id="4-3-cu-ndo-usar-std-array-o-std-vector" data-toc="4-3-cu-ndo-usar-std-array-o-std-vector">4.3 Cu&aacute;ndo Usar <code class="code" id="-py2pby_114">[]</code>, <code class="code" id="-py2pby_115">std::array</code>, o <code class="code" id="-py2pby_116">std::vector</code></h3><section class="chapter"><h4 id="4-3-1-arreglos-est-ticos" data-toc="4-3-1-arreglos-est-ticos">4.3.1 <code class="code" id="-py2pby_119">[]</code> (Arreglos Est&aacute;ticos)</h4><ul class="list _bullet" id="-py2pby_118"><li class="list__item" id="-py2pby_120"><p><span class="control" id="-py2pby_122">Uso</span>: Cuando el tama&ntilde;o del arreglo es fijo y conocido en tiempo de compilaci&oacute;n.</p></li><li class="list__item" id="-py2pby_121"><p><span class="control" id="-py2pby_123">Aplicaciones</span>: Peque&ntilde;os conjuntos de datos donde la eficiencia es crucial.</p></li></ul></section><section class="chapter"><h4 id="4-3-2-std-array" data-toc="4-3-2-std-array">4.3.2 <code class="code" id="-py2pby_126">std::array</code></h4><ul class="list _bullet" id="-py2pby_125"><li class="list__item" id="-py2pby_127"><p><span class="control" id="-py2pby_129">Uso</span>: Cuando se necesita un arreglo est&aacute;tico con las ventajas de la STL (iteradores, m&eacute;todos adicionales).</p></li><li class="list__item" id="-py2pby_128"><p><span class="control" id="-py2pby_130">Aplicaciones</span>: Situaciones donde el tama&ntilde;o es fijo pero se requieren las funcionalidades de la STL.</p></li></ul></section><section class="chapter"><h4 id="4-3-3-std-vector" data-toc="4-3-3-std-vector">4.3.3 <code class="code" id="-py2pby_133">std::vector</code></h4><ul class="list _bullet" id="-py2pby_132"><li class="list__item" id="-py2pby_134"><p><span class="control" id="-py2pby_136">Uso</span>: Cuando se necesita un arreglo din&aacute;mico que pueda cambiar de tama&ntilde;o durante la ejecuci&oacute;n del programa.</p></li><li class="list__item" id="-py2pby_135"><p><span class="control" id="-py2pby_137">Aplicaciones</span>: Grandes conjuntos de datos, listas donde se agregan o eliminan elementos frecuentemente.</p></li></ul></section></section></section><section class="chapter"><h2 id="5-manejo-de-memoria-con-std-vector-y-std-array" data-toc="5-manejo-de-memoria-con-std-vector-y-std-array">5. Manejo de Memoria con <code class="code" id="-py2pby_141">std::vector</code> y <code class="code" id="-py2pby_142">std::array</code></h2><section class="chapter"><h3 id="5-1-std-vector" data-toc="5-1-std-vector">5.1 <code class="code" id="-py2pby_145">std::vector</code></h3><ul class="list _bullet" id="-py2pby_144"><li class="list__item" id="-py2pby_146"><p><span class="control" id="-py2pby_149">Asignaci&oacute;n de Memoria</span>: <code class="code" id="-py2pby_150">std::vector</code> asigna memoria din&aacute;mica en el heap y gestiona autom&aacute;ticamente el redimensionamiento.</p></li><li class="list__item" id="-py2pby_147"><p><span class="control" id="-py2pby_151">Crecimiento Autom&aacute;tico</span>: Los <code class="code" id="-py2pby_152">std::vector</code> pueden crecer en tama&ntilde;o autom&aacute;ticamente; al exceder su capacidad actual, duplican su tama&ntilde;o, lo que puede implicar una reasignaci&oacute;n de memoria.</p></li><li class="list__item" id="-py2pby_148"><p><span class="control" id="-py2pby_153">Liberaci&oacute;n de Memoria</span>: La memoria es liberada autom&aacute;ticamente cuando el <code class="code" id="-py2pby_154">std::vector</code> sale del &aacute;mbito, o puede liberarse manualmente con <code class="code" id="-py2pby_155">.clear()</code> y <code class="code" id="-py2pby_156">.shrink_to_fit()</code>.</p></li></ul></section><section class="chapter"><h3 id="5-2-std-array" data-toc="5-2-std-array">5.2 <code class="code" id="-py2pby_159">std::array</code></h3><ul class="list _bullet" id="-py2pby_158"><li class="list__item" id="-py2pby_160"><p><span class="control" id="-py2pby_163">Asignaci&oacute;n de Memoria</span>: <code class="code" id="-py2pby_164">std::array</code> es un contenedor de tama&ntilde;o fijo; la memoria es asignada en el stack.</p></li><li class="list__item" id="-py2pby_161"><p><span class="control" id="-py2pby_165">No Redimensionable</span>: A diferencia de <code class="code" id="-py2pby_166">std::vector</code>, <code class="code" id="-py2pby_167">std::array</code> no puede cambiar de tama&ntilde;o.</p></li><li class="list__item" id="-py2pby_162"><p><span class="control" id="-py2pby_168">Liberaci&oacute;n de Memoria</span>: Al ser un contenedor de stack, la memoria se gestiona autom&aacute;ticamente y se libera al salir del &aacute;mbito.</p></li></ul></section></section><section class="chapter"><h2 id="6-buenas-pr-cticas" data-toc="6-buenas-pr-cticas">6. Buenas Pr&aacute;cticas</h2><ul class="list _bullet" id="-py2pby_169"><li class="list__item" id="-py2pby_170"><p><span class="control" id="-py2pby_174">Usar <code class="code" id="-py2pby_178">std::vector</code> para Arreglos Din&aacute;micos</span>: Evita gestionar manualmente la memoria usando arreglos din&aacute;micos con <code class="code" id="-py2pby_175">new</code> y <code class="code" id="-py2pby_176">delete</code>. En su lugar, usa <code class="code" id="-py2pby_177">std::vector</code> para aprovechar la gesti&oacute;n autom&aacute;tica de memoria y las funcionalidades adicionales.</p></li><li class="list__item" id="-py2pby_171"><p><span class="control" id="-py2pby_179">Usar <code class="code" id="-py2pby_182">std::array</code> o <code class="code" id="-py2pby_183">[]</code> para Tama&ntilde;os Fijos</span>: Si el tama&ntilde;o del arreglo es fijo y conocido en tiempo de compilaci&oacute;n, <code class="code" id="-py2pby_180">std::array</code> es preferible por su integraci&oacute;n con la STL, pero <code class="code" id="-py2pby_181">[]</code> sigue siendo &uacute;til en casos donde se requiere m&aacute;xima eficiencia.</p></li><li class="list__item" id="-py2pby_172"><p><span class="control" id="-py2pby_184">Verificaci&oacute;n de L&iacute;mites</span>: Usa <code class="code" id="-py2pby_185">.at()</code> en <code class="code" id="-py2pby_186">std::array</code> y <code class="code" id="-py2pby_187">std::vector</code> para evitar accesos fuera de los l&iacute;mites del arreglo.</p></li><li class="list__item" id="-py2pby_173"><p><span class="control" id="-py2pby_188">Liberar Memoria en Arreglos Din&aacute;micos</span>: Si usas <code class="code" id="-py2pby_189">new[]</code> para crear arreglos din&aacute;micos, aseg&uacute;rate de liberar la memoria con <code class="code" id="-py2pby_190">delete[]</code> para evitar fugas de memoria.</p></li></ul></section><section class="chapter"><h2 id="7-conclusi-n" data-toc="7-conclusi-n">7. Conclusi&oacute;n</h2><p id="-py2pby_191">La elecci&oacute;n entre arreglos est&aacute;ticos y din&aacute;micos, as&iacute; como entre <code class="code" id="-py2pby_192">[]</code>, <code class="code" id="-py2pby_193">std::array</code>, y <code class="code" id="-py2pby_194">std::vector</code>, depende de las necesidades espec&iacute;ficas del programa. Mientras que los arreglos est&aacute;ticos y <code class="code" id="-py2pby_195">std::array</code> son ideales para situaciones con tama&ntilde;o fijo, <code class="code" id="-py2pby_196">std::vector</code> proporciona la flexibilidad necesaria para trabajar con datos de tama&ntilde;o variable. La correcta gesti&oacute;n de la memoria y la elecci&oacute;n del contenedor adecuado son esenciales para escribir c&oacute;digo eficiente y seguro en C++.</p></section><div class="last-modified">Last modified: 19 agosto 2024</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="ejercicio-memoria.html" class="navigation-links__prev">Ejercicio Avanzado: Implementaci&oacute;n de Regresi&oacute;n Lineal Usando Registros, Apuntadores y Memoria Din&aacute;mica en C++</a><a href="ejercicio-clasificacion.html" class="navigation-links__next">Ejemplo de Aplicaci&oacute;n: Implementaci&oacute;n B&aacute;sica del Algoritmo k-NN en C++</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b408/app.js"></script></body></html>